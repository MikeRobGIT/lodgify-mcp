#!/usr/bin/env node
import { McpServer } from '@modelcontextprotocol/sdk/server/mcp.js'
import { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js'
import { ErrorCode, McpError } from '@modelcontextprotocol/sdk/types.js'
import { z } from 'zod'
import { config } from 'dotenv'
import { LodgifyClient } from './lodgify.js'

// Helper function to find properties when ID is unknown
async function findProperties(
  client: LodgifyClient,
  searchTerm?: string,
  includePropertyIds: boolean = true,
  limit: number = 10
): Promise<{
  properties: Array<{
    id: string
    name?: string
    source?: string
  }>
  message: string
  suggestions: string[]
}> {
  const properties: Array<{ id: string; name?: string; source?: string }> = []
  const propertyIds = new Set<string>()
  const suggestions: string[] = []

  try {
    // Get properties from property list API
    try {
      const propertiesData = await client.listProperties() as any
      const propertyList = propertiesData?.items || propertiesData || []
      
      for (const property of propertyList.slice(0, limit)) {
        if (property.id) {
          const propertyName = property.name || property.title || ''
          const matchesSearch = !searchTerm || 
            propertyName.toLowerCase().includes(searchTerm.toLowerCase())
          
          if (matchesSearch) {
            properties.push({
              id: property.id.toString(),
              name: propertyName,
              source: 'property_list'
            })
            propertyIds.add(property.id.toString())
          }
        }
      }
    } catch (error) {
      suggestions.push('Property list API may not be available or accessible')
    }

    // Get property IDs from recent bookings if enabled
    if (includePropertyIds && properties.length < limit) {
      try {
        const bookingsData = await client.listBookings() as any
        const bookings = bookingsData?.items || []
        
        const uniquePropertyIds = new Set<string>()
        for (const booking of bookings) {
          if (booking.property_id && !propertyIds.has(booking.property_id.toString())) {
            uniquePropertyIds.add(booking.property_id.toString())
          }
        }

        // Add property IDs from bookings
        for (const propId of Array.from(uniquePropertyIds).slice(0, limit - properties.length)) {
          properties.push({
            id: propId,
            name: `Property ${propId}`,
            source: 'bookings'
          })
          propertyIds.add(propId)
        }
      } catch (error) {
        suggestions.push('Could not retrieve property IDs from bookings')
      }
    }

    // Generate helpful suggestions
    if (properties.length === 0) {
      suggestions.push('No properties found. Try using lodgify_list_properties to see all properties.')
      suggestions.push('Check if your API key has proper permissions to access properties.')
    } else if (searchTerm && properties.length === 0) {
      suggestions.push(`No properties found matching "${searchTerm}". Try a broader search term.`)
    }

    if (properties.length > 0) {
      suggestions.push('Use one of these property IDs with availability tools like lodgify_check_next_availability')
      if (searchTerm) {
        suggestions.push('Property names are case-insensitive. Try partial matches for better results.')
      }
    }

    const message = properties.length > 0 
      ? `Found ${properties.length} property(ies)${searchTerm ? ` matching "${searchTerm}"` : ''}`
      : `No properties found${searchTerm ? ` matching "${searchTerm}"` : ''}`

    return {
      properties,
      message,
      suggestions
    }
  } catch (error) {
    return {
      properties: [],
      message: 'Error searching for properties',
      suggestions: [
        'Check your API key and permissions',
        'Try using lodgify_list_properties directly',
        'Verify your network connection'
      ]
    }
  }
}

// Load environment variables
config()

// Function to register all tools with the McpServer
function registerTools(server: McpServer, client: LodgifyClient): void {
  // Property Management Tools
  server.registerTool(
    'lodgify_list_properties',
    {
      title: 'List Properties',
      description: 'List all properties with optional filtering and pagination. Returns property details including names, IDs, locations, and basic configuration. Supports filtering by status, location, and other criteria.',
      inputSchema: {
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .optional()
          .describe('Optional query parameters for filtering and pagination (e.g., limit, offset, status)')
      }
    },
    async ({ params }) => {
      try {
        const result = await client.listProperties(params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_get_property',
    {
      title: 'Get Property Details',
      description: 'Retrieve comprehensive details for a specific property including configuration, amenities, room types, location information, and booking settings. Essential for understanding property structure before making bookings or checking availability.',
      inputSchema: {
        id: z.string().min(1).describe('Unique identifier of the property to retrieve'),
      }
    },
    async ({ id }) => {
      try {
        // Validate input directly since McpServer already parses the schema
        const result = await client.getProperty(id)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_list_property_rooms',
    {
      title: 'List Property Room Types',
      description: 'Retrieve all room types and configurations for a specific property. Returns room details including capacity, pricing structure, amenities, and booking rules. Use this before checking availability or making bookings to understand available accommodation options.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID to list room types for'),
      }
    },
    async ({ propertyId }) => {
      try {
        const result = await client.listPropertyRooms(propertyId)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_list_bookings',
    {
      title: 'List Bookings & Reservations',
      description: 'Retrieve all bookings with comprehensive filtering options. Filter by dates, status, property, guest information, and more. Returns booking details including guest info, dates, pricing, and payment status. Essential for managing reservations and analyzing booking patterns.',
      inputSchema: {
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .optional()
          .describe('Optional query parameters for filtering (date range, status, property ID, guest details, etc.)')
      }
    },
    async ({ params }) => {
      try {
        const result = await client.listBookings(params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_get_booking',
    {
      title: 'Get Booking Details',
      description: 'Retrieve complete details for a specific booking including guest information, property details, room assignments, pricing breakdown, payment status, special requests, and booking timeline. Use this for customer service inquiries and detailed booking management.',
      inputSchema: {
        id: z.string().min(1).describe('Unique booking/reservation ID to retrieve'),
      }
    },
    async ({ id }) => {
      try {
        const result = await client.getBooking(id)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_find_properties',
    {
      title: 'Find Properties',
      description: 'Find properties in the system when you don\'t know the exact property ID. Searches properties by name, gets property IDs from bookings, or lists all properties.',
      inputSchema: {
        searchTerm: z.string().optional().describe('Optional search term to filter properties by name (case-insensitive)'),
        includePropertyIds: z.boolean().default(true).optional().describe('Include property IDs found in recent bookings (default: true)'),
        limit: z.number().min(1).max(50).default(10).optional().describe('Maximum number of properties to return (default: 10)'),
      }
    },
    async ({ searchTerm, includePropertyIds, limit }) => {
      try {
        const result = await findProperties(client, searchTerm, includePropertyIds, limit)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_delete_booking',
    {
      title: 'Cancel/Delete Booking',
      description: 'Permanently cancel and delete a booking from the system. This is a destructive operation that cannot be undone. Use with extreme caution and ensure proper authorization. Consider using booking modification instead of deletion when possible.',
      inputSchema: {
        id: z.string().min(1).describe('Booking ID to cancel and delete permanently'),
      }
    },
    async ({ id }) => {
      try {
        const result = await client.deleteBooking(id)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Deleted Properties Tools
  server.registerTool(
    'lodgify_list_deleted_properties',
    {
      title: 'List Deleted Properties',
      description: 'Retrieve properties that have been soft-deleted from the system. Useful for auditing, recovery operations, and understanding property lifecycle. Returns properties that were previously active but have been removed from general availability.',
      inputSchema: {
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .optional()
          .describe('Optional query parameters for filtering deleted properties')
      }
    },
    async ({ params }) => {
      try {
        const result = await client.listDeletedProperties(params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Rates Management Tools
  server.registerTool(
    'lodgify_daily_rates',
    {
      title: 'Get Daily Rates Calendar',
      description: 'Retrieve daily pricing calendar for properties showing rates across date ranges. Essential for pricing analysis, revenue optimization, and understanding seasonal rate variations. Returns detailed rate information including base rates, modifiers, and availability-based pricing.',
      inputSchema: {
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .describe('Required: propertyId, from/to dates (YYYY-MM-DD format). Optional: roomTypeId, currency')
      }
    },
    async ({ params }) => {
      try {
        const result = await client.getDailyRates(params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_rate_settings',
    {
      title: 'Get Rate Settings & Configuration',
      description: 'Retrieve rate configuration settings including pricing rules, modifiers, seasonal adjustments, and rate calculation parameters. Essential for understanding how rates are calculated and configuring pricing strategies.',
      inputSchema: {
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .describe('Query parameters for rate settings (propertyId, currency, etc.)')
      }
    },
    async ({ params }) => {
      try {
        const result = await client.getRateSettings(params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_create_rate',
    {
      title: 'Create/Update Rates',
      description: 'Create or update pricing rates for specific properties and room types over date ranges. Use this to set seasonal pricing, special event rates, or update base pricing. Rates can be set for specific date ranges and room types.',
      inputSchema: {
        payload: z.object({
          propertyId: z.string().min(1).describe('Property to set rates for'),
          roomTypeId: z.string().min(1).describe('Room type to set rates for'),
          from: z.string().min(1).describe('Start date (YYYY-MM-DD)'),
          to: z.string().min(1).describe('End date (YYYY-MM-DD)'),
          rate: z.number().positive().describe('Rate amount per night'),
          currency: z.string().length(3).optional().describe('Currency code (e.g., USD, EUR)'),
        }).describe('Rate details including property, room type, dates, and rate amount'),
      }
    },
    async ({ payload }) => {
      try {
        const result = await client.createRate(payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_update_rate',
    {
      title: 'Update Existing Rate',
      description: 'Modify an existing rate entry with new pricing, dates, or currency. Use this to adjust previously set rates, extend date ranges, or update pricing for specific rate periods. Requires the rate ID from previous rate operations.',
      inputSchema: {
        id: z.string().min(1).describe('Unique rate ID to update'),
        payload: z.object({
          rate: z.number().positive().optional().describe('New rate amount per night'),
          currency: z.string().length(3).optional().describe('Currency code (e.g., USD, EUR)'),
          from: z.string().optional().describe('New start date (YYYY-MM-DD)'),
          to: z.string().optional().describe('New end date (YYYY-MM-DD)'),
        }).describe('Updated rate details - only provided fields will be changed'),
      }
    },
    async ({ id, payload }) => {
      try {
        const result = await client.updateRate(id, payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Booking Payment & Management Tools
  server.registerTool(
    'lodgify_get_booking_payment_link',
    {
      title: 'Get Booking Payment Link',
      description: 'Retrieve existing payment link for a booking including payment status, amount due, and link expiration. Use this to check if a payment link already exists or to get current payment details for customer service inquiries.',
      inputSchema: {
        id: z.string().min(1).describe('Booking ID to get payment link for'),
      }
    },
    async ({ id }) => {
      try {
        const result = await client.getBookingPaymentLink(id)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_create_booking_payment_link',
    {
      title: 'Create Booking Payment Link',
      description: 'Generate a secure payment link for a booking allowing guests to pay outstanding balances online. Useful for collecting deposits, final payments, or additional charges. The link will be sent to guests via email or can be shared directly.',
      inputSchema: {
        id: z.string().min(1).describe('Booking ID to create payment link for'),
        payload: z.object({
          amount: z.number().positive().optional().describe('Payment amount (defaults to booking balance)'),
          currency: z.string().length(3).optional().describe('Currency code (e.g., USD, EUR)'),
          description: z.string().max(500).optional().describe('Payment description for guest'),
        }).describe('Payment link configuration - amount, currency, and description'),
      }
    },
    async ({ id, payload }) => {
      try {
        const result = await client.createBookingPaymentLink(id, payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_update_key_codes',
    {
      title: 'Update Access Key Codes',
      description: 'Update access key codes for a booking to provide guests with property entry information. Used for smart locks, keypad codes, or other access control systems. Essential for self-check-in processes and property access management.',
      inputSchema: {
        id: z.string().min(1).describe('Booking ID to update key codes for'),
        payload: z.object({
          keyCodes: z.array(z.string()).optional().describe('Array of access codes/keys for the property'),
        }).describe('Access key codes and entry information'),
      }
    },
    async ({ id, payload }) => {
      try {
        const result = await client.updateKeyCodes(id, payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_create_booking',
    {
      title: 'Create New Booking',
      description: 'Create a new booking/reservation in the system. This will check availability, calculate pricing, and create a confirmed reservation. Ensure availability is checked first using availability tools before creating bookings to avoid conflicts.',
      inputSchema: {
        payload: z.object({
          propertyId: z.string().min(1).describe('Property ID to book'),
          from: z.string().min(1).describe('Check-in date (YYYY-MM-DD)'),
          to: z.string().min(1).describe('Check-out date (YYYY-MM-DD)'),
          guestBreakdown: z.object({
            adults: z.number().min(1).describe('Number of adult guests'),
            children: z.number().min(0).optional().describe('Number of children'),
            infants: z.number().min(0).optional().describe('Number of infants'),
          }).describe('Guest count breakdown'),
          roomTypes: z.array(z.object({
            id: z.string().min(1).describe('Room type ID'),
            quantity: z.number().min(1).optional().describe('Number of rooms (default: 1)'),
          })).describe('Room types and quantities to book'),
        }).describe('Complete booking details - property, dates, guests, and rooms'),
      }
    },
    async ({ payload }) => {
      try {
        const result = await client.createBooking(payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_update_booking',
    {
      title: 'Update Existing Booking',
      description: 'Modify an existing booking including dates, guest count, status, or other booking details. Use this for handling booking modifications, extensions, guest count changes, or status updates. Availability will be rechecked for date changes.',
      inputSchema: {
        id: z.string().min(1).describe('Booking ID to update'),
        payload: z.object({
          status: z.string().optional().describe('New booking status (confirmed, cancelled, etc.)'),
          guestBreakdown: z.object({
            adults: z.number().min(1).optional().describe('Updated number of adult guests'),
            children: z.number().min(0).optional().describe('Updated number of children'),
            infants: z.number().min(0).optional().describe('Updated number of infants'),
          }).optional().describe('Updated guest count breakdown'),
          from: z.string().optional().describe('New check-in date (YYYY-MM-DD)'),
          to: z.string().optional().describe('New check-out date (YYYY-MM-DD)'),
        }).describe('Updated booking details - only provided fields will be changed'),
      }
    },
    async ({ id, payload }) => {
      try {
        const result = await client.updateBooking(id, payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Availability Tools
  server.registerTool(
    'lodgify_availability_room',
    {
      title: 'Get Raw Availability (Room)',
      description: 'Get raw availability data for a specific room type (GET /v2/availability/{propertyId}/{roomTypeId}). Note: This returns technical availability data. For easier availability checking, use lodgify_check_next_availability or lodgify_get_availability_calendar instead.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID'),
        roomTypeId: z.string().min(1).describe('Room Type ID'),
        params: z.object({
          from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional().describe('Start date (YYYY-MM-DD)'),
          to: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional().describe('End date (YYYY-MM-DD)'),
        }).optional().describe('Optional query parameters including from/to dates (YYYY-MM-DD format)'),
      }
    },
    async ({ propertyId, roomTypeId, params }) => {
      try {
        const result = await client.getAvailabilityRoom(propertyId, roomTypeId, params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_availability_property',
    {
      title: 'Get Raw Availability (Property)',
      description: 'Get raw availability data for a property (GET /v2/availability/{propertyId}). Note: This returns technical availability data. For easier availability checking, use lodgify_check_next_availability or lodgify_get_availability_calendar instead.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID'),
        params: z.object({
          from: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional().describe('Start date (YYYY-MM-DD)'),
          to: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional().describe('End date (YYYY-MM-DD)'),
        }).optional().describe('Optional query parameters including from/to dates (YYYY-MM-DD format)'),
      }
    },
    async ({ propertyId, params }) => {
      try {
        const result = await client.getAvailabilityProperty(propertyId, params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Enhanced Availability Helper Tools
  server.registerTool(
    'lodgify_check_next_availability',
    {
      title: 'Find Next Available Date',
      description: 'Find the next available date for a property by analyzing bookings. Returns when the property is next available and for how long. If property ID is unknown, use lodgify_find_properties first.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID'),
        fromDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional().describe('Start date to check from (YYYY-MM-DD). Defaults to today if not provided.'),
        daysToCheck: z.number().min(1).max(365).optional().describe('Number of days to check ahead (1-365). Defaults to 90 days.'),
      }
    },
    async ({ propertyId, fromDate, daysToCheck }) => {
      try {
        const result = await client.getNextAvailableDate(propertyId, fromDate, daysToCheck)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_check_date_range_availability',
    {
      title: 'Check Date Range Availability',
      description: 'Verify if a specific date range is available for booking at a property. Returns detailed availability status including any conflicts or restrictions. Use this before creating bookings to ensure availability and avoid booking conflicts.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID to check availability for'),
        checkInDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').describe('Desired check-in date (YYYY-MM-DD)'),
        checkOutDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').describe('Desired check-out date (YYYY-MM-DD)'),
      }
    },
    async ({ propertyId, checkInDate, checkOutDate }) => {
      try {
        const result = await client.checkDateRangeAvailability(propertyId, checkInDate, checkOutDate)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_get_availability_calendar',
    {
      title: 'Get Availability Calendar View',
      description: 'Retrieve a visual calendar view of property availability showing available, booked, and blocked dates. Perfect for displaying availability to guests, planning maintenance windows, or understanding booking patterns over time.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID to get calendar for'),
        fromDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional().describe('Calendar start date (YYYY-MM-DD). Defaults to today'),
        daysToShow: z.number().min(1).max(90).optional().describe('Number of days to display (1-90). Default: 30 days'),
      }
    },
    async ({ propertyId, fromDate, daysToShow }) => {
      try {
        const result = await client.getAvailabilityCalendar(propertyId, fromDate, daysToShow)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Quote & Messaging Tools
  server.registerTool(
    'lodgify_get_quote',
    {
      title: 'Get Booking Quote & Pricing',
      description: 'Calculate detailed pricing quote for a property booking including room rates, taxes, fees, and total cost. Essential for providing accurate pricing to guests before booking confirmation. Supports complex parameters for multiple room types and add-ons.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID to quote'),
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .describe('Quote parameters: dates (from/to), room types (roomTypes[0].Id), guest breakdown (guest_breakdown[adults]), add-ons. Uses bracket notation for complex parameters.')
      }
    },
    async ({ propertyId, params }) => {
      try {
        const result = await client.getQuote(propertyId, params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_get_thread',
    {
      title: 'Get Messaging Thread',
      description: 'Retrieve a messaging conversation thread including all messages, participants, and thread metadata. Use this for customer service inquiries, guest communication history, or managing ongoing conversations with guests and staff.',
      inputSchema: {
        threadGuid: z.string().min(1).describe('Unique thread identifier (GUID) for the conversation'),
      }
    },
    async ({ threadGuid }) => {
      try {
        const result = await client.getThread(threadGuid)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Property Management Tools
  server.registerTool(
    'lodgify_update_property_availability',
    {
      title: 'Update Property Availability Rules',
      description: 'Modify property availability settings including blocking/opening dates, minimum stay requirements, and maximum stay limits. Use this to set maintenance periods, seasonal restrictions, or special booking rules for specific date ranges.',
      inputSchema: {
        propertyId: z.string().min(1).describe('Property ID to update availability for'),
        payload: z.object({
          from: z.string().min(1).describe('Start date for availability change (YYYY-MM-DD)'),
          to: z.string().min(1).describe('End date for availability change (YYYY-MM-DD)'),
          available: z.boolean().describe('Whether property is available for booking in this period'),
          minStay: z.number().min(0).optional().describe('Minimum stay requirement in nights'),
          maxStay: z.number().min(0).optional().describe('Maximum stay limit in nights'),
        }).describe('Availability update configuration including dates, availability status, and stay restrictions'),
      }
    },
    async ({ propertyId, payload }) => {
      try {
        const result = await client.updatePropertyAvailability(propertyId, payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Webhook Management Tools
  server.registerTool(
    'lodgify_subscribe_webhook',
    {
      title: 'Subscribe to Webhook Events',
      description: 'Set up webhook subscriptions to receive real-time notifications for booking events, property changes, and other system updates. Essential for integrating external systems and automating workflows based on Lodgify events.',
      inputSchema: {
        payload: z.object({
          event: z.string().min(1).describe('Event type to subscribe to (e.g., booking.created, booking.updated)'),
          targetUrl: z.string().url().describe('HTTPS URL endpoint to receive webhook notifications'),
        }).describe('Webhook subscription configuration - event type and notification endpoint'),
      }
    },
    async ({ payload }) => {
      try {
        const result = await client.subscribeWebhook(payload)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  server.registerTool(
    'lodgify_list_webhooks',
    {
      title: 'List Active Webhook Subscriptions',
      description: 'Retrieve all active webhook subscriptions including event types, target URLs, and subscription status. Use this to audit existing integrations, troubleshoot webhook delivery issues, or manage webhook configurations.',
      inputSchema: {
        params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()]))
          .optional()
          .describe('Optional query parameters for filtering webhooks by status, event type, etc.')
      }
    },
    async ({ params }) => {
      try {
        const result = await client.listWebhooks(params)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )

  // Store handle for dangerous tool - can be disabled at runtime
  server.registerTool(
    'lodgify_delete_webhook',
    {
      title: 'Delete Webhook Subscription',
      description: 'Permanently remove a webhook subscription and stop receiving event notifications. This is a destructive operation that cannot be undone. Use this to clean up unused integrations or when changing webhook configurations.',
      inputSchema: {
        id: z.string().min(1).describe('Webhook subscription ID to delete'),
      }
    },
    async ({ id }) => {
      try {
        const result = await client.deleteWebhook(id)
        return {
          content: [
            {
              type: 'text',
              text: JSON.stringify(result, null, 2),
            },
          ],
        }
      } catch (error) {
        handleToolError(error)
      }
    }
  )
}

// Helper function to handle tool errors with proper JSON-RPC error codes
function handleToolError(error: unknown): never {
  // Handle MCP errors (already properly formatted)
  if (error instanceof McpError) {
    throw error
  }

  // Handle Zod validation errors
  if (error instanceof z.ZodError) {
    throw new McpError(
      ErrorCode.InvalidParams,
      'Invalid input parameters',
      {
        validationErrors: error.issues.map(issue => ({
          path: issue.path.join('.'),
          message: issue.message,
          code: issue.code,
        }))
      }
    )
  }

  // Handle Lodgify API errors
  if (error instanceof Error) {
    // Check for specific error patterns
    const message = error.message.toLowerCase()
    
    // Rate limiting errors
    if (message.includes('429') || message.includes('rate limit')) {
      throw new McpError(
        ErrorCode.RequestTimeout,
        'Rate limit exceeded. Please try again later.',
        { 
          originalError: error.message,
          retryAfter: (error as any).retryAfter 
        }
      )
    }
    
    // Authentication errors
    if (message.includes('401') || message.includes('unauthorized') || message.includes('api key')) {
      throw new McpError(
        ErrorCode.InvalidRequest,
        'Authentication failed. Please check your API key.',
        { originalError: error.message }
      )
    }
    
    // Not found errors
    if (message.includes('404') || message.includes('not found')) {
      throw new McpError(
        ErrorCode.InvalidParams,
        'Resource not found. Please check the ID and try again.',
        { originalError: error.message }
      )
    }
    
    // Network errors
    if (message.includes('econnrefused') || message.includes('network') || message.includes('fetch')) {
      throw new McpError(
        ErrorCode.InternalError,
        'Network error occurred while connecting to Lodgify API',
        { originalError: error.message }
      )
    }
    
    // Generic API errors with details
    const errorDetails = (error as any)?.detail || (error as any)?.response?.data
    if (errorDetails) {
      throw new McpError(
        ErrorCode.InternalError,
        error.message,
        errorDetails
      )
    }
    
    // Default error handling
    throw new McpError(
      ErrorCode.InternalError,
      error.message,
      { type: 'LodgifyAPIError' }
    )
  }

  // Unknown error type
  throw new McpError(
    ErrorCode.InternalError,
    'An unexpected error occurred',
    { error: String(error) }
  )
  
  // Store tool handle for dynamic management (example for last tool)
}

// Function to register resources with the McpServer
function registerResources(server: McpServer) {
  // Health check resource
  server.registerResource(
    'health',
    'lodgify://health',
    {
      title: 'Health Check',
      description: 'Check the health status of the Lodgify MCP server',
      mimeType: 'application/json',
    },
    async (uri) => {
      const health = {
        status: 'healthy',
        service: 'lodgify-mcp',
        version: '0.1.0',
        timestamp: new Date().toISOString(),
      }

      return {
        contents: [
          {
            uri: uri.href,
            mimeType: 'application/json',
            text: JSON.stringify(health, null, 2),
          },
        ],
      }
    }
  )
}

// Function to set up server with client injection for testing
export function setupServer(injectedClient?: LodgifyClient) {
  const server = new McpServer(
    {
      name: 'lodgify-mcp',
      version: '0.1.0',
    },
    {
      capabilities: {
        tools: {
          // We support all standard tool capabilities
          listChanged: true,  // Server can notify clients when tool list changes
        },
        resources: {
          // We support all standard resource capabilities
          subscribe: true,    // Clients can subscribe to resource changes
          listChanged: true,  // Server can notify clients when resource list changes
        },
        logging: {},          // Support for structured logging (if client requests it)
        // Note: We do not support prompts, so we don't declare that capability
      },
      // Enable notification debouncing to reduce client noise
      debouncedNotificationMethods: [
        'notifications/tools/list_changed',
        'notifications/resources/list_changed',
      ],
    },
  )
  
  const client = injectedClient || (() => {
    const apiKey = process.env.LODGIFY_API_KEY
    if (!apiKey) {
      throw new Error('LODGIFY_API_KEY environment variable is required')
    }
    return new LodgifyClient(apiKey)
  })()

  // Register tools and resources
  registerTools(server, client)
  registerResources(server)

  // Return server and client for testing
  return { server, client }
}

// Initialize server for production
const { server } = setupServer()

// ============================================================================
// Zod Validation Schemas
// ============================================================================

// Common validation schemas
const IdSchema = z.string().min(1).max(100).regex(/^[a-zA-Z0-9_-]+$/, 'ID contains invalid characters')
const GuidSchema = z.string().min(1).max(100).regex(/^[a-zA-Z0-9_-]+$/, 'GUID contains invalid characters')

// Specific payload schemas
const PaymentLinkPayloadSchema = z.object({
  amount: z.number().positive().optional(),
  currency: z.string().length(3).optional(),
  description: z.string().max(500).optional(),
  // Add other expected fields as needed
}).strict()

const KeyCodesPayloadSchema = z.object({
  keyCodes: z.array(z.string()).optional(),
  // Add other expected fields as needed
}).strict()

// New booking creation and update schemas
const CreateBookingPayloadSchema = z.object({
  propertyId: z.string().min(1),
  from: z.string().min(1),
  to: z.string().min(1),
  guestBreakdown: z.object({
    adults: z.number().min(1),
    children: z.number().min(0).optional(),
    infants: z.number().min(0).optional(),
  }),
  roomTypes: z.array(z.object({
    id: z.string().min(1),
    quantity: z.number().min(1).optional(),
  })),
  // Add other expected fields as needed
}).strict()

const UpdateBookingPayloadSchema = z.object({
  status: z.string().optional(),
  guestBreakdown: z.object({
    adults: z.number().min(1).optional(),
    children: z.number().min(0).optional(),
    infants: z.number().min(0).optional(),
  }).optional(),
  from: z.string().optional(),
  to: z.string().optional(),
  // Add other expected fields as needed
}).strict()

// Availability update schema
const AvailabilityUpdatePayloadSchema = z.object({
  from: z.string().min(1),
  to: z.string().min(1),
  available: z.boolean(),
  minStay: z.number().min(0).optional(),
  maxStay: z.number().min(0).optional(),
  // Add other expected fields as needed
}).strict()

// Webhook schemas
const WebhookSubscribePayloadSchema = z.object({
  event: z.string().min(1),
  targetUrl: z.string().url(),
  // Add other expected fields as needed
}).strict()

// Rate management schemas
const CreateRatePayloadSchema = z.object({
  propertyId: z.string().min(1),
  roomTypeId: z.string().min(1),
  from: z.string().min(1),
  to: z.string().min(1),
  rate: z.number().positive(),
  currency: z.string().length(3).optional(),
  // Add other expected fields as needed
}).strict()

const UpdateRatePayloadSchema = z.object({
  rate: z.number().positive().optional(),
  currency: z.string().length(3).optional(),
  from: z.string().optional(),
  to: z.string().optional(),
  // Add other expected fields as needed
}).strict()

// Property Management Schemas
const ListPropertiesSchema = z.object({
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
})

const GetPropertySchema = z.object({
  id: IdSchema,
})

const ListPropertyRoomsSchema = z.object({
  propertyId: IdSchema,
})

const ListDeletedPropertiesSchema = z.object({
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
})

// Rates Management Schemas
const DailyRatesSchema = z.object({
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])),
})

const RateSettingsSchema = z.object({
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])),
})

// Booking Management Schemas
const ListBookingsSchema = z.object({
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
})

const GetBookingSchema = z.object({
  id: IdSchema,
})

const GetBookingPaymentLinkSchema = z.object({
  id: IdSchema,
})

const CreateBookingPaymentLinkSchema = z.object({
  id: IdSchema,
  payload: PaymentLinkPayloadSchema,
})

const UpdateKeyCodesSchema = z.object({
  id: IdSchema,
  payload: KeyCodesPayloadSchema,
})

// Availability Schemas
const AvailabilityRoomSchema = z.object({
  propertyId: IdSchema,
  roomTypeId: IdSchema,
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
})

const AvailabilityPropertySchema = z.object({
  propertyId: IdSchema,
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
})

// Quote & Messaging Schemas
const GetQuoteSchema = z.object({
  propertyId: IdSchema,
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])),
})

const GetThreadSchema = z.object({
  threadGuid: GuidSchema,
})

// New endpoint schemas
const CreateBookingSchema = z.object({
  payload: CreateBookingPayloadSchema,
})

const UpdateBookingSchema = z.object({
  id: IdSchema,
  payload: UpdateBookingPayloadSchema,
})

const DeleteBookingSchema = z.object({
  id: IdSchema,
})

const UpdatePropertyAvailabilitySchema = z.object({
  propertyId: IdSchema,
  payload: AvailabilityUpdatePayloadSchema,
})

const WebhookSubscribeSchema = z.object({
  payload: WebhookSubscribePayloadSchema,
})

const ListWebhooksSchema = z.object({
  params: z.record(z.string(), z.union([z.string(), z.number(), z.boolean()])).optional(),
})

const DeleteWebhookSchema = z.object({
  id: IdSchema,
})

const CreateRateSchema = z.object({
  payload: CreateRatePayloadSchema,
})

const UpdateRateSchema = z.object({
  id: IdSchema,
  payload: UpdateRatePayloadSchema,
})

// New Availability Helper Schemas
const FindPropertiesSchema = z.object({
  searchTerm: z.string().optional(),
  includePropertyIds: z.boolean().default(true).optional(),
  limit: z.number().min(1).max(50).default(10).optional(),
})

const CheckNextAvailabilitySchema = z.object({
  propertyId: IdSchema,
  fromDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional(),
  daysToCheck: z.number().min(1).max(365).optional(),
})

const CheckDateRangeAvailabilitySchema = z.object({
  propertyId: IdSchema,
  checkInDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format'),
  checkOutDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format'),
})

const GetAvailabilityCalendarSchema = z.object({
  propertyId: IdSchema,
  fromDate: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be in YYYY-MM-DD format').optional(),
  daysToShow: z.number().min(1).max(90).optional(),
})

// ============================================================================
// Tools are now registered in the registerTools function above
// ============================================================================

// ============================================================================
// Tool handlers are now implemented via registerTool calls above
// ============================================================================

// ============================================================================
// Resources are now registered in the registerResources function above
// ============================================================================

// ============================================================================
// Start Server
// ============================================================================

async function main() {
  const transport = new StdioServerTransport()

  // Handle errors
  transport.onerror = (error) => {
    console.error('Transport error:', error)
  }

  // Handle shutdown gracefully
  process.on('SIGINT', async () => {
    console.error('Shutting down...')
    await server.close()
    process.exit(0)
  })

  process.on('SIGTERM', async () => {
    console.error('Shutting down...')
    await server.close()
    process.exit(0)
  })

  // Connect and start server
  await server.connect(transport)
  console.error('Lodgify MCP server started successfully')
}

// Only run main if this is the entry point (not imported for testing)
if (import.meta.url === `file://${process.argv[1]}` || process.argv[1]?.endsWith('/server.js')) {
  main().catch((error) => {
    console.error('Fatal error:', error)
    process.exit(1)
  })
}